{
  "version": 3,
  "sources": ["../index.ts", "../../../esc/standards.js"],
  "sourcesContent": ["\nimport Monitor from \"../../esmonitor/src\";\nimport  { specialKeys, defaultPath } from \"../../esc/standards\"\n\nconst listenerObject = Symbol('listenerObject')\nconst toSet = Symbol('toSet')\nconst isConfigObject = (o) => specialKeys.listeners.format in o || specialKeys.listeners.branch in o || specialKeys.listeners.trigger in o || specialKeys.listeners.bind in o\n\nconst initializedStatus = 'INITIALIZED'\nconst registeredStatus = 'REGISTERED'\n\nconst globalFrom = {} as any\nconst globalTo = {} as any\n\nconst globalActive = {}\n\nconst subscriptionKey = Symbol('subscriptionKey')\nconst configKey = Symbol('configKey')\nconst toResolveWithKey = Symbol('toResolveWithKey')\n\nclass Edgelord {\n\n    monitor: Monitor\n    original = {};\n    active = {}\n    globals: any = {}\n    context: any = {}\n    rootPath: string = ''\n    status = ''\n    \n\n\n    #triggers: any[] = []\n    #queue: any[] = []\n    #toResolveWith: Edgelord\n    // #sendsToExternalGraph = false\n\n    constructor (listeners = {}, root, context) {\n        this.context = context\n        this.rootPath = root\n        this.original = listeners\n\n        const globals = [{name: 'active', ref: globalActive}, {name: 'from', ref: globalFrom}, {name: 'to', ref: globalTo}]\n        globals.forEach((o) => {\n            if (!o.ref[this.context.id]) o.ref[this.context.id] = {}\n            this.globals[o.name] = o.ref[this.context.id]\n        })\n\n        this.#toResolveWith = this.getManager()\n        this.runEachListener(listeners, this.addToGlobalLog)\n    }\n\n    getManager = (mode ='from') => {\n        \n            // Check if a higher-level listener is sending information from this root context\n            let target = (mode === 'to') ? this.globals.to : this.globals.from\n            this.rootPath.split(this.context.options.keySeparator).forEach((key) => {\n                if (!target[key]) target[key] = {}\n                target = target[key]\n            })\n\n            // if (Object.keys(target).length) this.#sendsToExternalGraph = true\n            return target[toResolveWithKey] ?? this\n    }\n\n    onStart = (f) => {\n        const res = this.#toResolveWith\n        const isSame = res === this\n        if (isSame) {\n            if (this.status === initializedStatus) f()\n            else this.#queue.push(f)\n        } else res.onStart(f)\n    }\n\n    runEachListener = (listeners, callback) => {\n        if (!callback) return\n        for (let toPath in listeners) {\n            const from = listeners[toPath]\n\n            if (!from) {\n                console.warn('Skipping empty listener:', toPath)\n                continue;\n            }\n\n            if (from && typeof from === 'object') {\n                for (let fromPath in from) callback(fromPath, toPath, from[fromPath])\n            } \n            \n            // Immediate Absolute Paths Only\n            else {\n                if (typeof toPath === 'string') callback(from, toPath, toPath)\n                else console.error('Improperly Formatted Listener', toPath)\n            }\n        }\n\n    }\n\n    register = (listeners = this.original) =>  {\n\n        this.runEachListener(listeners, this.add)\n        this.status = registeredStatus\n    }\n\n    #initialize = (o) => {\n        const res = this.context.monitor.get(o.path, 'info')\n        if (typeof res.value === 'function') {\n            const args = (Array.isArray(o.args)) ? o.args : [o.args]\n            res.value(...args)\n        }\n        else console.error('Cannot yet trigger values...', o)\n    }\n\n    initialize = (o?) => {\n        if (!this.status) this.#triggers.push(o)\n        else if (this.status === registeredStatus) {\n            this.status = initializedStatus\n            this.#triggers.forEach(this.#initialize)\n            this.#queue.forEach(f => f())\n            this.#queue = []\n            this.#triggers = []\n        } else this.#initialize(o)\n    }\n\n    start = () => {\n        this.register()\n        this.initialize()\n    }\n\n    #getAbsolutePath = (name) => {\n        return (!name || !this.rootPath || name.includes(this.rootPath)) ? name : [this.rootPath, name].join(this.context.monitor.options.keySeparator)\n    }\n\n    #getPathInfo = (path) => {\n\n        const output = {\n            absolute: {},\n            relative: {}\n        } as any\n\n        // Transform name to absolute \n        path =  this.#getAbsolutePath(path)\n        let rel = this.rootPath ? path.replace(`${this.rootPath}.`, '') : path\n        const baseArr = path.split(this.context.options.keySeparator)\n        output.absolute.array = [this.context.id, ...baseArr]\n        output.relative.array = rel.split(this.context.options.keySeparator)\n        const obj = this.context.monitor.get(output.relative.array, undefined, this.context.instance) // Allow for getting properties\n        const isComponent = obj?.hasOwnProperty(specialKeys.path)\n\n        // Updates based on default\n        if (isComponent) {\n            output.absolute.array.push(defaultPath)\n            output.relative.array.push(defaultPath)\n        }\n\n        output.absolute.value = output.absolute.array.slice(1).join(this.context.options.keySeparator) // update path\n        output.relative.value = output.relative.array.join(this.context.options.keySeparator) // update path\n        \n        return output\n    }\n\n    add = (from, to, value: any = true, subscription) => {\n\n\n        const fromInfo = this.#getPathInfo(from)\n        const toInfo = this.#getPathInfo(to)\n\n        // Check global for subscription\n        const absPath = fromInfo.absolute.value\n        if (!subscription) subscription = this.globals.active[absPath]?.[subscriptionKey]\n\n        // Only subscribe once\n        if (!subscription) {\n            subscription = this.context.monitor.on(fromInfo.absolute.array, (path, _, update) => this.activate(path, update), {\n                ref: this.context.instance,\n                path: fromInfo.relative.array\n            })\n        }\n\n        const info = {\n            value,\n            [listenerObject]: true\n        }\n\n        const refs = [this.active, this.globals.active]\n\n        refs.forEach(ref => {\n            if(!ref[absPath]) ref[absPath] = {}\n            const base = ref[absPath]\n            if (!base[subscriptionKey]) {\n                Object.defineProperty(base, subscriptionKey, {\n                    value: subscription,\n                    configurable: true\n                })\n            }\n            base[toInfo.absolute.value] = info\n        })\n\n        // // Update Original\n        // let base = this.original[toInfo.relative.value]\n        // if (!base) base = this.original[toInfo.relative.value] = {}\n        // if (typeof base !== 'object') {\n        //     if (typeof base === 'function') base = this.original[toInfo.relative.value] = {[Symbol('function listener')]: base} // Move function to arbitrary key\n        //     else base = this.original[toInfo.relative.value] = {[base]: true} // Move string to  a complex listener\n        // }\n        // base[fromInfo.relative.value] = value // complex listener\n\n        // Initalize triggers (possible on higherl-level manager)\n        const args = value[specialKeys.listeners.trigger]\n        if (args) this.#toResolveWith.initialize({\n            path: fromInfo.absolute.array,\n            args\n        })\n\n        this.addToGlobalLog(absPath)\n\n\n        return info\n    }\n\n    addToGlobalLog = (path, mode = 'from') => {\n\n        const absolutePath = this.#getAbsolutePath(path)\n\n        // Register in global registry\n        let target = (mode === 'to') ? this.globals.to : this.globals.from\n        const globalPath = absolutePath.split(this.context.options.keySeparator)\n        globalPath.forEach((key) => {\n            if (!target[key]) target[key] = {}\n            target = target[key]\n            if (!(target[toResolveWithKey])) target[toResolveWithKey] = this // Always set with the lowest\n        })\n\n    }\n\n    // Local removal\n    remove = (from, to) => {\n        const fromInfo = this.#getPathInfo(from)\n        const toInfo = this.#getPathInfo(to)\n\n        const path = [fromInfo.absolute.value, toInfo.absolute.value]\n        const toRemove = [\n            { ref: this.active, path },\n            { ref: this.globals.active, path, unlisten: true }, // Remove subscription if required\n            // { ref: this.original, path: [toInfo.relative.value, fromInfo.relative.value] }, // Just removing from the list\n        ]\n\n        toRemove.forEach(o => {\n            const { ref, path, unlisten } = o\n\n            let base = ref[path[0]]\n\n            if (typeof base === 'object') {\n                delete base[path[1]] // complex listener\n                if (Object.keys(base).length === 0) {\n                    delete ref[path[0]]\n                    const sub = base[subscriptionKey]\n                    if (unlisten && sub) {\n                        this.context.monitor.remove(sub) // Cleaning up subscriptions (active only)\n                    }\n                    delete base[subscriptionKey]\n                }\n\n            } else delete ref[path[0]] // simple listener\n\n        })\n\n    }\n\n    // Local clearing\n    clear = (name) => {\n        const value = this.#getAbsolutePath(name)\n\n        Object.keys(this.active).forEach(from => {\n            Object.keys(this.active[from]).forEach(to => {\n                if (\n                    !value\n                    || from.slice(0, value.length) === value // Matches from\n                    || to.slice(0, value.length) === value // Matches to\n                ) this.remove(from, to)\n            })\n        })\n    }\n\n    has = (from, ref=this.active) => !!ref[from]\n\n    get = (from, ref=this.active) => ref[from]\n\n\n\n    // ----------------- Global Flow Activation Management -----------------\n    activate = (from, update) => {\n\n    const listenerGroups = [{\n        info: this.get(from, this.globals.active),\n        name\n    }]\n\n    listenerGroups.forEach(group => {\n\n        const info = group.info\n\n        if (info) {\n\n            if (info[listenerObject]) {\n                this.pass(from, {\n                    value: info.value,\n                    parent: this.active,\n                    key: group.name,\n                    subscription: info.subscription,\n                    __value: true\n                }, update)\n            } else if (typeof info === 'object') {\n                for (let key in info) {\n                    this.pass(from, {\n                        parent: info,\n                        key,\n                        subscription: info[key].subscription,\n                        value: info[key].value,\n                    }, update)\n                }\n            } else console.error('Improperly Formatted Listener', info)\n        }\n    })\n}\n\npass = (from, target, update) => {\n\n    const id = this.context.id\n\n    let parent, key, subscription\n    const isValue = target?.__value\n    parent = target.parent\n    key = target.key\n\n    subscription = target.subscription\n\n    // const rootArr = root.split(this.context.options.keySeparator)\n    const info = target.parent[key]\n    target = info.value\n\n    let config = info?.[configKey] // Grab config\n\n    let ogValue = target\n    const type = typeof target\n\n    const checkIfSetter = (path, willSet) => {\n\n        const info = this.context.monitor.get(path, 'info')\n        if (info.exists) {\n            const val = info.value\n            const noDefault = typeof val !== 'function' && !val?.default\n            const value = (noDefault) ? toSet : val\n\n            const res = { value }\n\n            if (willSet) {\n                target = res.value\n                parent[key] = res\n            }\n\n            return res\n        } else return { value: undefined } //, root: undefined }\n\n    }\n\n    const transform = (willSet?) => {\n        const fullPath = [id]\n        // if (root) fullPath.push(...rootArr) // correcting for relative string\n        fullPath.push(...key.split(this.context.options.keySeparator))\n        return checkIfSetter(fullPath, willSet)\n    }\n\n    // ------------------ Grab Correct Target to Listen To ------------------\n\n\n    const getPathArray = (latest) => {\n        const path = [id]\n        const topPath: any[] = []\n        if (this.rootPath) topPath.push(...this.rootPath.split(this.context.options.keySeparator)) // correcting for relative string\n        topPath.push(...latest.split(this.context.options.keySeparator))\n        path.push(...topPath)\n        return path\n    }\n\n    // Confirmation of the target\n    if (typeof target === 'boolean') {\n        if (!isValue) transform(true)\n        else console.error(`Cannot use a boolean for ${specialKeys.listeners.value}...`)\n    }\n\n    // Name of the target\n    else if (type === 'string') {\n        const path = getPathArray(ogValue)\n        checkIfSetter(path, true)\n\n        if (isValue) {\n            parent[key] = { [ogValue]: parent[key] }\n            key = ogValue\n        }\n    }\n\n    else if (target && type === 'object') {\n\n        // Check if configuration object\n        const isConfig = isConfigObject(ogValue)\n\n        if (isConfig) {\n\n            if ('value' in ogValue) {\n                if (isValue) {\n                    target = parent[key] = ogValue.value // setting value\n                } else {\n                    target = parent[key].value = ogValue.value // setting value\n                }\n            } else transform(true)\n\n            if (ogValue){\n                if (ogValue) config = ogValue\n            }\n\n            Object.defineProperty(parent[key], configKey, { value: config })\n        }\n\n    }\n\n    // ------------------ Special Keywords ------------------\n    let isValidInput = true\n\n    if (config) {\n\n        \n        const bindKey = specialKeys.listeners.value\n        if (bindKey in config) {\n\n            // (de)Register listeners at runtime...\n            const path = getPathArray(config[bindKey].original ?? config[bindKey])\n            if (typeof config[bindKey] === 'string') {\n                const res = this.context.monitor.get(path)\n                if (!res)  target = `because ${path.slice(1).join(this.context.options.keySeparator)} does not point correctly to an existing component.`\n                else {\n                    config[bindKey] = {\n                        value: res,\n                        original: config[bindKey]\n                    }\n                }\n            } else if (!config[bindKey].value.esParent) {\n                target = `because ${config[bindKey].original ?? id.toString()} has become unparented.`\n            }\n\n        } \n        \n        else {\n\n            const branchKey = specialKeys.listeners.branch\n            const formatKey = specialKeys.listeners.format\n\n            if (branchKey in config) {\n\n                const isValid = config[branchKey].find(o => {\n\n                    let localValid: boolean[] = []\n                    if ('condition' in o) localValid.push(o.condition(update)) // Condition Function\n                    if ('equals' in o) localValid.push(o.equals === update) // Equality Check\n                    const isValidLocal = localValid.length > 0 && localValid.reduce((a, b) => a && b, true)\n\n                    if (isValidLocal) {\n                        if ('value' in o)  update = o.value // set first argument to branch value\n                    }\n\n                    return isValidLocal\n                })\n\n                if (!isValid) isValidInput = false\n            }\n\n\n            \n            // NOTE: May turn into an array here\n            if (formatKey in config) {\n                try {\n                    update = config[formatKey](update)\n                    if (update === undefined) isValidInput = false\n                } catch (e) { console.error('Failed to format arguments', e) }\n            }\n\n        }\n    }\n\n    // ------------------ Handle Target ------------------\n\n    if (\n        isValidInput // Ensure input is valid\n        && update !== undefined // Ensure input is not exactly undefined (though null is fine)\n    ) {\n\n        const arrayUpdate = Array.isArray(update) ? update : [update]\n\n        // Set New Value on Parent\n        if (target === toSet) {\n            const parentPath = [id]\n            // if (root) parentPath.push(...rootArr) // TODO: Check if this needs fixing\n            parentPath.push(...key.split(this.context.options.keySeparator))\n            const idx = parentPath.pop()\n            const info = this.context.monitor.get(parentPath, 'info')\n            info.value[idx] = update\n        }\n\n        // Direct Object with Default Function\n        else if (target?.default) target.default.call(target, ...arrayUpdate) // Call with parent context\n\n        // Direct Function\n        else if (typeof target === 'function') {\n            const noContext = parent[key][listenerObject]\n            if (noContext) target.call(config?.[specialKeys.listeners.bind]?.value ?? this.context.instance, ...arrayUpdate) // Call with top-level context\n            else target(...arrayUpdate) // Call with default context\n        }\n\n        // Failed\n        else {\n\n            let baseMessage = (key) ? `listener: ${from} \u2014> ${key}` : `listener from ${from}`\n            if (parent) {\n                console.warn(`Deleting ${baseMessage}`, target)\n                delete parent[key]\n            } else console.error(`Failed to add ${baseMessage}`, target)\n        }\n    }\n}\n\n\n}\n\nexport default Edgelord", "export const keySeparator = '.'\n\nexport const defaultPath = 'default'\n\nexport const esSourceKey = '__esmpileSourceBundle'\n\nexport const specialKeys = {\n\n    start: 'esConnected', // asked to start\n    stop: 'esDisconnected',\n    connected: 'esReady', // wait until connected\n\n    hierarchy: 'esDOM',\n    element: 'esElement',\n    webcomponents: 'esComponents',\n    attributes: 'esAttributes',\n\n    listeners: {\n        value: 'esListeners',\n        branch: 'esBranch',\n        bind: 'esBind',\n        trigger: 'esTrigger',\n        format: 'esFormat',\n    },\n\n    trigger: 'esTrigger',\n    compose: 'esCompose',\n\n    uri: 'esURI',\n    reference: 'esReference',\n\n    childPosition: 'esChildPosition',\n\n    attribute: '__isescomponent',\n\n    parent: 'esParent',\n    component: 'esComponent',\n\n    source: 'esSource',\n    path: '__isESComponent',\n\n    animate: 'esAnimate',\n    options: '__esOptions',\n    states: '__esStates',\n\n    promise: '__esComponentPromise',\n    proxy: '__esProxy',\n    editor: 'esCode',\n\n    flow: '__esManager',\n\n    original: 'esOriginal',\n\n    resize: 'esOnResize',    \n}"],
  "mappings": "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",
  "names": ["edgelord_exports", "__export", "edgelord_default", "__toCommonJS", "defaultPath", "specialKeys", "listenerObject", "toSet", "isConfigObject", "o", "specialKeys", "initializedStatus", "registeredStatus", "globalFrom", "globalTo", "globalActive", "subscriptionKey", "configKey", "toResolveWithKey", "Edgelord", "listeners", "root", "context", "#triggers", "#queue", "mode", "target", "key", "f", "res", "#toResolveWith", "callback", "toPath", "from", "fromPath", "#initialize", "args", "#getAbsolutePath", "name", "#getPathInfo", "path", "output", "rel", "baseArr", "defaultPath", "to", "value", "subscription", "fromInfo", "toInfo", "absPath", "_", "update", "info", "ref", "base", "absolutePath", "unlisten", "sub", "group", "id", "parent", "isValue", "config", "ogValue", "type", "checkIfSetter", "willSet", "val", "transform", "fullPath", "getPathArray", "latest", "topPath", "isValidInput", "bindKey", "branchKey", "formatKey", "localValid", "isValidLocal", "a", "b", "e", "arrayUpdate", "parentPath", "idx", "baseMessage", "edgelord_default"]
}
